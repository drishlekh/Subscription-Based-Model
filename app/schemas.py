# # app/schemas.py
# from pydantic import BaseModel, Field, field_validator
# from typing import List, Optional
# from datetime import date
# from .models import SubscriptionStatusEnum # Import the enum

# # --- Plan Schemas ---
# class PlanBase(BaseModel):
#     """
#     Why this Pydantic model is necessary:
#     - Defines the common attributes for a plan, used as a base for other plan-related schemas.
#     - Ensures that data related to plans conforms to a specific structure and type.
#     What it's doing:
#     - Specifies expected fields: `name`, `price`, `features`, `duration_days`.
#     """
#     name: str = Field(..., min_length=3, max_length=100)
#     price: float = Field(..., ge=0) # ge=0 means "greater than or equal to 0"
#     features: Optional[str] = None
#     duration_days: int = Field(..., gt=0)

# class PlanCreate(PlanBase):
#     """
#     Why this Pydantic model is necessary:
#     - Specifically used for validating the data when creating a new plan.
#     - Inherits from PlanBase, so it includes all common plan attributes.
#     What it's doing:
#     - In this case, it's identical to PlanBase but could include creation-specific fields if needed.
#     """
#     pass # No additional fields needed for creation beyond PlanBase

# class Plan(PlanBase):
#     """
#     Why this Pydantic model is necessary:
#     - Defines the structure for returning plan data in API responses.
#     - Includes the `id` field, which is generated by the database.
#     What it's doing:
#     - Adds `id` to the fields inherited from `PlanBase`.
#     - `Config.from_attributes = True` (formerly `orm_mode`): Allows Pydantic to read data directly from
#       SQLAlchemy model instances (e.g., `Plan.from_orm(db_plan_object)`).
#     """
#     id: int

#     class Config:
#         from_attributes = True


# # --- User Schemas (Example) ---
# class UserBase(BaseModel):
#     username: str
#     email: str

# class UserCreate(UserBase):
#     pass

# class User(UserBase):
#     id: int
#     class Config:
#         from_attributes = True

# # --- Subscription Schemas ---
# class SubscriptionBase(BaseModel):
#     """
#     Why this Pydantic model is necessary:
#     - Defines common attributes for a subscription.
#     - Used as a base for creation, update, and response schemas.
#     What it's doing:
#     - Specifies `user_id` and `plan_id` as required fields for identifying the user and plan.
#     """
#     user_id: int
#     plan_id: int

# class SubscriptionCreate(BaseModel): # Not inheriting from SubscriptionBase to have specific fields for creation
#     """
#     Why this Pydantic model is necessary:
#     - Validates the incoming request data when a user subscribes to a plan.
#     - Ensures only `user_id` and `plan_id` are provided by the client for creating a subscription.
#     What it's doing:
#     - Specifies `user_id` and `plan_id` as the only required fields for the POST /subscriptions endpoint.
#       Other fields like start_date, end_date, status are calculated/set by the server.
#     """
#     user_id: int = Field(..., gt=0)
#     plan_id: int = Field(..., gt=0)


# class SubscriptionUpdate(BaseModel):
#     """
#     Why this Pydantic model is necessary:
#     - Validates the incoming request data when updating a subscription (e.g., changing plans).
#     - Ensures only the `new_plan_id` is provided for an update.
#     What it's doing:
#     - Specifies `new_plan_id` as the required field for the PUT /subscriptions/{userId} endpoint.
#     """
#     new_plan_id: int = Field(..., gt=0)


# class Subscription(SubscriptionBase): # Inherits user_id, plan_id
#     """
#     Why this Pydantic model is necessary:
#     - Defines the structure for returning subscription data in API responses.
#     - Includes calculated/database-generated fields like `id`, `start_date`, `end_date`, and `status`.
#     - Can also include details of the associated plan.
#     What it's doing:
#     - Adds `id`, `start_date`, `end_date`, `status` to the fields from `SubscriptionBase`.
#     - `plan: Plan`: Embeds the full details of the associated plan in the response.
#     - `Config.from_attributes = True`: Enables ORM mode for easy conversion from SQLAlchemy objects.
#     """
#     id: int
#     start_date: date
#     end_date: date
#     status: SubscriptionStatusEnum
#     plan: Plan # Embed plan details in the response

#     class Config:
#         from_attributes = True
#         use_enum_values = True # To serialize enum members to their values (e.g., "ACTIVE")




# app/schemas.py
from pydantic import BaseModel, Field, field_validator, EmailStr
from typing import List, Optional
from datetime import date
from .models import SubscriptionStatusEnum

# --- Plan Schemas ---
class PlanBase(BaseModel):
    name: str = Field(..., min_length=3, max_length=100)
    price: float = Field(..., ge=0) # Greater than or equal to 0
    features: Optional[str] = None
    duration_days: int = Field(..., gt=0)

class PlanCreate(PlanBase):
    pass

class Plan(PlanBase):
    id: int
    class Config:
        from_attributes = True

# --- User Schemas ---
class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr # Pydantic will validate if it's a valid email format

class UserCreate(UserBase):
    """
    Why this Pydantic model is necessary:
    - Validates incoming data for creating a new user, including their plain-text password.
    What it's doing:
    - Inherits `username` and `email` from `UserBase`.
    - Adds a `password` field. This password will be hashed before storing.
    """
    password: str = Field(..., min_length=8)

class User(UserBase): # Schema for returning User data (without password)
    """
    Why this Pydantic model is necessary:
    - Defines the structure for returning user data in API responses.
    - Importantly, it does NOT include the password (or hashed_password) for security.
    What it's doing:
    - Includes `id`, `username`, and `email`.
    """
    id: int
    class Config:
        from_attributes = True

# --- Token Schemas ---
class Token(BaseModel):
    """
    Why this Pydantic model is necessary:
    - Defines the structure of the response when a user successfully logs in.
    What it's doing:
    - `access_token`: The JWT string.
    - `token_type`: Usually "bearer".
    """
    access_token: str
    token_type: str

class TokenData(BaseModel):
    """
    Why this Pydantic model is necessary:
    - Defines the expected structure of the data embedded within the JWT payload.
    What it's doing:
    - `username`: Stores the username of the authenticated user. Can be None.
    """
    username: Optional[str] = None

# --- Subscription Schemas ---
class SubscriptionBase(BaseModel):
    user_id: int # This will usually be derived from the authenticated user
    plan_id: int

class SubscriptionCreate(BaseModel): # Client only sends plan_id; user_id comes from token
    """
    Why this Pydantic model is necessary:
    - Validates incoming data for creating a new subscription.
    - Note: `user_id` is no longer directly provided by the client in the request body
      for this endpoint; it will be derived from the authenticated user's JWT.
    What it's doing:
    - Specifies `plan_id` as the required field.
    """
    plan_id: int = Field(..., gt=0)

class SubscriptionUpdate(BaseModel):
    new_plan_id: int = Field(..., gt=0)

class Subscription(SubscriptionBase):
    id: int
    start_date: date
    end_date: date
    status: SubscriptionStatusEnum
    plan: Plan
    user_id: int # Keep user_id here for response consistency

    class Config:
        from_attributes = True
        use_enum_values = True